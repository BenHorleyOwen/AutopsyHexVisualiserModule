/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package HexVisualiserModule;
import java.awt.*;
import org.openide.util.NbBundle;
import org.openide.nodes.Node;
import org.openide.util.lookup.ServiceProvider;
//import org.sleuthkit.autopsy.contentviewers.utils.ViewerPriority;
import org.sleuthkit.autopsy.corecomponentinterfaces.DataContentViewer;
import org.sleuthkit.autopsy.corecomponents.DataContentViewerUtility;
import org.sleuthkit.datamodel.Content;
import java.util.concurrent.ExecutionException;
import javax.swing.SwingWorker;
import javax.swing.text.StyledDocument;
import org.sleuthkit.datamodel.TskCoreException;


/**
 *
 * @author benho
 */
@ServiceProvider(service = DataContentViewer.class)
public class HexVisualiser extends org.sleuthkit.autopsy.corecomponents.DataContentViewerHex implements DataContentViewer{
    private static final long PAGE_LENGTH = 16384;
    private final byte[] data = new byte[(int) PAGE_LENGTH];
    private static int currentPage = 1;
    private int totalPages;
    private Content dataSource;
    final private static char[] hexArray = "0123456789ABCDEF".toCharArray(); //NON-NLS
    private HexWorker worker;
    private StyledDocument doc;
    private StyledDocument KeyList; 
//UI
        /**
     * Creates new form ContentViewerJPanel
     */
    public HexVisualiser(){
        initComponents();
        
    }
    @Override
    public void resetComponent() {
        currentPage = 1;
        this.dataSource = null;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        nextPageButton = new javax.swing.JButton();
        prevPageButton = new javax.swing.JButton();
        currentPageLabel = new javax.swing.JLabel();
        ofLabel = new javax.swing.JLabel();
        totalPageLabel = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        HexText = new javax.swing.JTextPane();
        jScrollPane3 = new javax.swing.JScrollPane();
        KeyArea = new javax.swing.JTextPane();

        org.openide.awt.Mnemonics.setLocalizedText(nextPageButton, org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.nextPageButton.text")); // NOI18N
        nextPageButton.setActionCommand(org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.nextPageButton.actionCommand")); // NOI18N
        nextPageButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextPageButtonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(prevPageButton, org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.prevPageButton.text")); // NOI18N
        prevPageButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                prevPageButtonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(currentPageLabel, org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.currentPageLabel.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(ofLabel, org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.ofLabel.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(totalPageLabel, org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.totalPageLabel.text")); // NOI18N

        HexText.setFont(new java.awt.Font("Monospaced", 0, 12)); // NOI18N
        jScrollPane2.setViewportView(HexText);

        jScrollPane3.setViewportView(KeyArea);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(currentPageLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(ofLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(totalPageLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(prevPageButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(nextPageButton)
                        .addContainerGap())
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 307, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 240, javax.swing.GroupLayout.PREFERRED_SIZE))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(nextPageButton)
                    .addComponent(prevPageButton)
                    .addComponent(currentPageLabel)
                    .addComponent(ofLabel)
                    .addComponent(totalPageLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 259, Short.MAX_VALUE)
                    .addComponent(jScrollPane3))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void nextPageButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextPageButtonActionPerformed
        setDataViewByPageNumber(currentPage + 1);
    }//GEN-LAST:event_nextPageButtonActionPerformed

    private void prevPageButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_prevPageButtonActionPerformed
        setDataViewByPageNumber(currentPage - 1);
    }//GEN-LAST:event_prevPageButtonActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextPane HexText;
    private javax.swing.JTextPane KeyArea;
    private javax.swing.JLabel currentPageLabel;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JButton nextPageButton;
    private javax.swing.JLabel ofLabel;
    private javax.swing.JButton prevPageButton;
    private javax.swing.JLabel totalPageLabel;
    // End of variables declaration//GEN-END:variables
   

//Returns the title of this viewer to display in the tab.
    @Override
    public String getTitle() {
        return "Hex Visualiser";
    }
//Returns a short description of this viewer to use as a tool tip for its tab.
    @Override
    public String getToolTip() {
        return "Displays the hex of a compatible file and highlights the internal structure";
    }
//Create and return a new instance of your viewer. The reason that this is needed is because the specific viewer modules will be found via NetBeans Lookup and the type will only be DataContentViewer. This method is used to get an instance of your specific type.
    @Override
    public DataContentViewer createInstance() {
        return new HexVisualiser();
    }
//Return the Swing Component to display. Implementations of this method that extend JPanel and do a 'return this;'. Otherwise return an internal instance of the JPanel.
    @Override
    public Component getComponent() {
        return this;
    }
//Checks whether the given node is supported by the viewer. This will be used enable for MBR records
    @Override
    public boolean isSupported(Node node) { 
        Content content = DataContentViewerUtility.getDefaultContent(node);
        try{return super.isSupported(node) && content.getClass().getName().equals("org.sleuthkit.datamodel.Volume");} //&& extension.equals("mbr");}mbr isnt a file type what kind of moron am i
        catch(Exception e){}
        return false;
    }
//Checks whether the given viewer is preferred for the Node.
    @Override
    public int isPreferred(Node node) {
        int a = 8;
        return a;
    }

    @Override
    public void setNode(Node node) {
        Content content = DataContentViewerUtility.getDefaultContent(node);
        if (content == null) {
            return;
        }
        
        dataSource = content;
        totalPages = 0;
        if (dataSource.getSize() > 0) {
            totalPages = Math.round((dataSource.getSize() - 1) / PAGE_LENGTH) + 1;
        }
        totalPageLabel.setText(Integer.toString(totalPages));

        this.setDataViewByPageNumber(1);
        
    }
    private void setComponentsVisibility(boolean isVisible) {
        currentPageLabel.setVisible(isVisible);
        totalPageLabel.setVisible(isVisible);
        ofLabel.setVisible(isVisible);
        prevPageButton.setVisible(isVisible);
        nextPageButton.setVisible(isVisible);
        }
    private void setDataViewByPageNumber(int page) {
        if (page == 0) {
            return;
        }
        launchWorker(dataSource, (page - 1) * PAGE_LENGTH, page);
    }
    private void launchWorker(Content source, long offset, int page) {
        if (dataSource == null) {
            return;
        }
        worker = new HexVisualiser.HexWorker(source, offset, page);
        setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
        worker.execute();
    }

    /**
     * SwingWorker to fetch hex from the given data source.
     */
    private class HexWorker extends SwingWorker<String, Void> {

        private final byte[] data = new byte[(int) PAGE_LENGTH];
        private final long offset;
        private final Content content;
        private final int newCurrentPage;
        private String errorText = "";


        HexWorker(Content content, long offset, int newCurrentPage) {
            this.content = content;
            this.offset = offset;
            this.newCurrentPage = newCurrentPage;

        }

        @Override
        protected String doInBackground() throws Exception {
            int bytesRead = 0;
            if (content.getSize() > 0) {
                try {
                    bytesRead = content.read(data, offset, PAGE_LENGTH); 
                } catch (TskCoreException ex) {
                    errorText = NbBundle.getMessage(this.getClass(), "DataContentViewerHex.setDataView.errorText", offset, offset + PAGE_LENGTH);
                }
            }

            
            if (bytesRead <= 0) {
                errorText = NbBundle.getMessage(this.getClass(), "DataContentViewerHex.setDataView.errorText", offset, offset + PAGE_LENGTH);
            }

            if (errorText.isEmpty()) {
                int showLength = bytesRead < PAGE_LENGTH ? bytesRead : (int) PAGE_LENGTH;
                try{
                    Object[] result = HexVisualiserModule.DataConversion.byteArrayToHex(data, showLength, offset);
                    doc = (StyledDocument) result[0];
                    KeyList = (StyledDocument) result[1];
                    return "success"; 
                } catch (Exception e){errorText = "error occured during byte array conversion"; return errorText;}
            } else {
                return errorText;
            }
        }

        @Override
        public void done() {
            if (isCancelled()) {
                return;
            }

            try {
                if("success".equals(get())){
                    HexText.setDocument(doc);
                    KeyArea.setDocument(KeyList);
                    HexText.repaint();
                    KeyArea.repaint();
                }
                
                if ((errorText.isEmpty()) && (newCurrentPage < totalPages)) {
                    nextPageButton.setEnabled(true);
                } else {
                    nextPageButton.setEnabled(false);
                }

                if ((errorText.isEmpty()) && (newCurrentPage > 1)) {
                    prevPageButton.setEnabled(true);
                } else {
                    prevPageButton.setEnabled(false);
                }
                //ui updates
                currentPageLabel.setText(Integer.toString(newCurrentPage));
                setComponentsVisibility(true); 
                HexText.setCaretPosition(0);
                currentPage = newCurrentPage;
                setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));

            } catch (InterruptedException | ExecutionException ex) {
            }
        }
    }
}

