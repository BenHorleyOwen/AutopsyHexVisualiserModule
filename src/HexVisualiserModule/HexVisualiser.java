/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package HexVisualiserModule;
import java.awt.*;
import org.openide.util.NbBundle;
import org.openide.nodes.Node;
import org.openide.util.lookup.ServiceProvider;
//import org.sleuthkit.autopsy.contentviewers.utils.ViewerPriority;
import org.sleuthkit.autopsy.corecomponentinterfaces.DataContentViewer;
import org.sleuthkit.autopsy.corecomponents.DataContentViewerUtility;
import org.sleuthkit.autopsy.datamodel.DataConversion;
import org.sleuthkit.datamodel.AbstractFile;
import org.sleuthkit.datamodel.Content;
import java.io.File;
import java.io.IOException;
import java.util.concurrent.ExecutionException;
import javax.swing.SwingWorker;
import org.apache.commons.io.FileUtils;
import org.openide.util.Exceptions;
import org.sleuthkit.datamodel.TskCoreException;

/**
 *
 * @author benho
 */
@ServiceProvider(service = DataContentViewer.class)
public class HexVisualiser extends org.sleuthkit.autopsy.corecomponents.DataContentViewerHex implements DataContentViewer{
    private File pattern = null;//global variable to be set when doing a support check, i have no clue how else to access the node.
    private boolean patternDone = false;//called when patternWorker is completed
    private static final long PAGE_LENGTH = 16384;
    private final byte[] data = new byte[(int) PAGE_LENGTH];
    private static int currentPage = 1;
    private int totalPages;
    private Content dataSource;

    private HexWorker worker;
    private PatternWorker Pworker;
//UI
        /**
     * Creates new form ContentViewerJPanel
     */
    public HexVisualiser(){
        initComponents();
        
    }
    @Override
    public void resetComponent() {
        // clear / reset the fields
        currentPage = 1;
        this.dataSource = null;
        this.pattern = null;
        patternDone = false;
        //currentPageLabel.setText(""); this line stops the module from initialising, my best guess is that it cals reset component before the component is initialised 
        //totalPageLabel.setText("");
        //setComponentsVisibility(false); // hides the components that not needed
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();
        HexText = new java.awt.TextArea();
        nextPageButton = new javax.swing.JButton();
        prevPageButton = new javax.swing.JButton();
        currentPageLabel = new javax.swing.JLabel();
        ofLabel = new javax.swing.JLabel();
        totalPageLabel = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        KeyArea = new javax.swing.JTextArea();

        org.openide.awt.Mnemonics.setLocalizedText(jButton1, org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.jButton1.text")); // NOI18N
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        HexText.setEditable(false);
        HexText.setFont(new java.awt.Font("Monospaced", 0, 12)); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(nextPageButton, org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.nextPageButton.text")); // NOI18N
        nextPageButton.setActionCommand(org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.nextPageButton.actionCommand")); // NOI18N
        nextPageButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextPageButtonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(prevPageButton, org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.prevPageButton.text")); // NOI18N
        prevPageButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                prevPageButtonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(currentPageLabel, org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.currentPageLabel.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(ofLabel, org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.ofLabel.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(totalPageLabel, org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.totalPageLabel.text")); // NOI18N

        KeyArea.setColumns(20);
        KeyArea.setFont(new java.awt.Font("Monospaced", 0, 12)); // NOI18N
        KeyArea.setRows(5);
        jScrollPane1.setViewportView(KeyArea);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap(309, Short.MAX_VALUE)
                        .addComponent(currentPageLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(ofLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(totalPageLabel)
                        .addGap(18, 18, 18)
                        .addComponent(prevPageButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(nextPageButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton1))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(HexText, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton1)
                    .addComponent(nextPageButton)
                    .addComponent(prevPageButton)
                    .addComponent(currentPageLabel)
                    .addComponent(ofLabel)
                    .addComponent(totalPageLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(HexText, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 396, Short.MAX_VALUE))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        ParsePattern patternObjects = new ParsePattern(this.pattern);//creates the list of objects to be iterated through
        
    }//GEN-LAST:event_jButton1ActionPerformed

    private void nextPageButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextPageButtonActionPerformed
        setDataViewByPageNumber(currentPage + 1);
    }//GEN-LAST:event_nextPageButtonActionPerformed

    private void prevPageButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_prevPageButtonActionPerformed
        setDataViewByPageNumber(currentPage - 1);
    }//GEN-LAST:event_prevPageButtonActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private java.awt.TextArea HexText;
    private javax.swing.JTextArea KeyArea;
    private javax.swing.JLabel currentPageLabel;
    private javax.swing.JButton jButton1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JButton nextPageButton;
    private javax.swing.JLabel ofLabel;
    private javax.swing.JButton prevPageButton;
    private javax.swing.JLabel totalPageLabel;
    // End of variables declaration//GEN-END:variables
   

//Autopsy will call this when this panel is focused with the file that should be analyzed. When called with null, must clear all references to previous nodes.
//Returns the title of this viewer to display in the tab.
    @Override
    public String getTitle() {
        return "Hex Visualiser";
    }
//Returns a short description of this viewer to use as a tool tip for its tab.
    @Override
    public String getToolTip() {
        return "Displays the hex of a compatible file and highlights the internal structure";
    }
//Create and return a new instance of your viewer. The reason that this is needed is because the specific viewer modules will be found via NetBeans Lookup and the type will only be DataContentViewer. This method is used to get an instance of your specific type.
    @Override
    public DataContentViewer createInstance() {
        return new HexVisualiser();
    }
//Return the Swing Component to display. Implementations of this method that extend JPanel and do a 'return this;'. Otherwise return an internal instance of the JPanel.
    @Override
    public Component getComponent() {
        return this;
    }
//Checks whether the given node is supported by the viewer. This will be used to enable or disable the tab for the viewer. use this for disabling module when pattern not held, create list for this to refer to held in component init
    @Override
    public boolean isSupported(Node node) {//a new if statement needs to be placed here which checks against the given file patterns 
        //create a check based off of the node file type to see if an associated pattern exists, if not return false, also check against whatever the super class was doing
        //if pattern exists, parse but not here, parsing should create a key to be displayed into the frame
        AbstractFile file = node.getLookup().lookup(AbstractFile.class);
        String extension = file.getNameExtension();
        if ("jpg".equals(extension)){extension = "jpeg";}//unifies types to match pattern repository
        try{
            this.pattern = new File("src\\HexVisualiserModule\\patterns\\"+extension+".hexpat");
            return super.isSupported(node) && pattern.exists();//returns if it passes the usual hex viewer tests and if the file exists
        } //the pattern file, assigned during support check and then passed into parser method
        catch(Exception e){
        
        }
        return false;
    }
//Checks whether the given viewer is preferred for the Node.
    @Override
    public int isPreferred(Node node) {
        int a = 6;
        return a;
        //the below code had some library import error and has been replaced by int 6, to be forgotten forever hopefully.
        //return ViewerPriority.viewerPriority.Level.getFlag();//gives the highest level of priority for the nodes this can run against
    }

    @Override
    public void setNode(Node node) {//because set node only runs when the module is clicked on the data doesnt display until interacted with
        Content content = DataContentViewerUtility.getDefaultContent(node);
        if (content == null) {
            return;
        }
        
        dataSource = content;
        totalPages = 0;
        if (dataSource.getSize() > 0) {
            totalPages = Math.round((dataSource.getSize() - 1) / PAGE_LENGTH) + 1;
        }
        totalPageLabel.setText(Integer.toString(totalPages));

        this.setDataViewByPageNumber(1);//this should create a worker which then displays the hex
        //launch a pattern worker which will analyse the entire node in the background, the set dataview method should be able to tell when the pattern is loaded
        
    }
    private void setComponentsVisibility(boolean isVisible) {
        currentPageLabel.setVisible(isVisible);
        totalPageLabel.setVisible(isVisible);
        ofLabel.setVisible(isVisible);
        prevPageButton.setVisible(isVisible);
        nextPageButton.setVisible(isVisible);
        }
    private void setDataViewByPageNumber(int page) {
        if (page == 0) {
            return;
        }
        launchWorker(dataSource, (page - 1) * PAGE_LENGTH, page);//creates a new worker when the page number is changed
    }
    private void launchWorker(Content source, long offset, int page) {//creates a swing worker to display the hex from the given file
        if (dataSource == null) {
            return;
        }
        worker = new HexVisualiser.HexWorker(source, offset, page);
        setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));//uncertain what this is/does must find out
        worker.execute();
    }

    /**
     * SwingWorker to fetch hex from the given data source.
     */
    private class HexWorker extends SwingWorker<String, Void> {

        private final byte[] data = new byte[(int) PAGE_LENGTH];
        private final long offset;
        private final Content content;
        private final int newCurrentPage;
        private String errorText = "";

        HexWorker(Content content, long offset, int newCurrentPage) {//constructor
            this.content = content;
            this.offset = offset;
            this.newCurrentPage = newCurrentPage;
        }

        @Override
        protected String doInBackground() throws Exception {//when a swing worker is on the worker thread the do in background method is called, it isnt called within this program, but sitll runs
            int bytesRead = 0;
            if (content.getSize() > 0) {
                try {
                    bytesRead = content.read(data, offset, PAGE_LENGTH); // read the data
                } catch (TskCoreException ex) {//if no bytes to read, errors and doesnt display anything
                    errorText = NbBundle.getMessage(this.getClass(), "DataContentViewerHex.setDataView.errorText", offset, offset + PAGE_LENGTH);
                }
            }

            // set the data on the bottom and show it
            if (bytesRead <= 0) {//if no bytes to read, errors and doesnt display anything
                errorText = NbBundle.getMessage(this.getClass(), "DataContentViewerHex.setDataView.errorText", offset, offset + PAGE_LENGTH);
            }

            if (errorText.isEmpty()) {
                int showLength = bytesRead < PAGE_LENGTH ? bytesRead : (int) PAGE_LENGTH;
                return DataConversion.byteArrayToHex(data, showLength, offset);//converts the bytes to hex by the amount of bytes, limited at the page length constant
            } else {
                return errorText;//returns the error if one was found rather than converting the byte array
            }
        }

        @Override
        public void done() {//executes after do in background is completed
            if (isCancelled()) {
                return;
            }

            try {
                String text = get();//retrieves results from background method
                HexText.setText(text);//sets display in visualiser module
                //below this, a swing worker needs to be made which can take the pattern file, parse through it and then display the highlighted patterns in the module
                if(totalPages == 1){//currently only making it work if the entire files hex view can be seen
                    Pworker = new HexVisualiser.PatternWorker(text, pattern);
                    Pworker.execute();
                }
                //ColourCode(HexText, text, 9); // Color every 9 characters differently for this example, modular range will be used later based off of patern matching
                // disable or enable the next button
                if ((errorText.isEmpty()) && (newCurrentPage < totalPages)) {
                    nextPageButton.setEnabled(true);
                } else {
                    nextPageButton.setEnabled(false);
                }

                if ((errorText.isEmpty()) && (newCurrentPage > 1)) {
                    prevPageButton.setEnabled(true);
                } else {
                    prevPageButton.setEnabled(false);
                }
                //ui updates
                currentPageLabel.setText(Integer.toString(newCurrentPage));
                setComponentsVisibility(true); // shows the components that not needed
                HexText.setCaretPosition(0);
                currentPage = newCurrentPage;
                setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));

            } catch (InterruptedException | ExecutionException ex) {
            }
        }
    }
    private class PatternWorker extends SwingWorker<String, Void>{//text field string passed into pattern worker which should take the file, highlight the bytes and then display them back
        //done using a swing worker to utilise threading and not hinder efficiency of the program
        private final byte[] data = new byte[(int) PAGE_LENGTH];
        private String errorText = "";
        private String text = "";
        private String pattern = null;
        private String highlightedResult="";//temp
        
        @SuppressWarnings("deprecation")//sick and tired i genuinely dont care if its depreciated do the damn thing i imported you for
        PatternWorker(String text, File pattern) {//constructor
            this.text = text;
            try {
                this.pattern = FileUtils.readFileToString(pattern);
            } catch (IOException ex) {
                Exceptions.printStackTrace(ex);
            }
        } 
        @Override
        protected String doInBackground() throws Exception {
            int bytesRead = 0;
            try {
                //in this section the pattern must parse or have been parsed, and the objects list must be made to colour the code 
                    //ParsePattern(this.text); // read the data
                    ImHexHighlighter highlighter = new ImHexHighlighter();
                    highlightedResult = highlighter.highlight(this.text, this.pattern);
                } 
            catch (Exception e) {//errors add to the text with stops the worker from returning the result
                    errorText = NbBundle.getMessage(this.getClass(), "DataContentViewerHex.setDataView.errorText");
                }
            if (errorText.isEmpty()) {
                //
                //int showLength = bytesRead < PAGE_LENGTH ? bytesRead : (int) PAGE_LENGTH;
                //return DataConversion.byteArrayToHex(data, showLength, offset);//converts the bytes to hex by the amount of bytes, limited at the page length constant
                return highlightedResult;
            } else {
                return errorText;//returns the error if one was found rather than converting the byte array
            }
            }

        @Override
        protected void done() {//sets the text once the worker is complete
            try {
                String text = get();//retrieves results from background method
                HexText.setText(text);//sets display in visualiser module
            } catch (Exception ignore) {
            }
        }
    }
    
}

