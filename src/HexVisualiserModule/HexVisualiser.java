/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package HexVisualiserModule;
import java.awt.*;
import org.openide.util.NbBundle;
import org.openide.nodes.Node;
import org.openide.util.lookup.ServiceProvider;
//import org.sleuthkit.autopsy.contentviewers.utils.ViewerPriority;
import org.sleuthkit.autopsy.corecomponentinterfaces.DataContentViewer;
import org.sleuthkit.autopsy.corecomponents.DataContentViewerUtility;
import org.sleuthkit.datamodel.AbstractFile;
import org.sleuthkit.datamodel.Content;
import java.io.File;
import java.util.concurrent.ExecutionException;
import javax.swing.SwingWorker;
import javax.swing.text.StyledDocument;
import org.sleuthkit.datamodel.TskCoreException;


/**
 *
 * @author benho
 */
@ServiceProvider(service = DataContentViewer.class)
public class HexVisualiser extends org.sleuthkit.autopsy.corecomponents.DataContentViewerHex implements DataContentViewer{
    private static final long PAGE_LENGTH = 16384;
    private final byte[] data = new byte[(int) PAGE_LENGTH];
    private static int currentPage = 1;
    private int totalPages;
    private Content dataSource;
    final private static char[] hexArray = "0123456789ABCDEF".toCharArray(); //NON-NLS
    private HexWorker worker;
    private StyledDocument doc;
//UI
        /**
     * Creates new form ContentViewerJPanel
     */
    public HexVisualiser(){
        initComponents();
        
    }
    @Override
    public void resetComponent() {
        // clear / reset the fields
        currentPage = 1;
        this.dataSource = null;
        //currentPageLabel.setText(""); this line stops the module from initialising, my best guess is that it cals reset component before the component is initialised 
        //totalPageLabel.setText("");
        //setComponentsVisibility(false); // hides the components that not needed
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        nextPageButton = new javax.swing.JButton();
        prevPageButton = new javax.swing.JButton();
        currentPageLabel = new javax.swing.JLabel();
        ofLabel = new javax.swing.JLabel();
        totalPageLabel = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        KeyArea = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        HexText = new javax.swing.JTextPane();

        org.openide.awt.Mnemonics.setLocalizedText(nextPageButton, org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.nextPageButton.text")); // NOI18N
        nextPageButton.setActionCommand(org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.nextPageButton.actionCommand")); // NOI18N
        nextPageButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextPageButtonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(prevPageButton, org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.prevPageButton.text")); // NOI18N
        prevPageButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                prevPageButtonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(currentPageLabel, org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.currentPageLabel.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(ofLabel, org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.ofLabel.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(totalPageLabel, org.openide.util.NbBundle.getMessage(HexVisualiser.class, "HexVisualiser.totalPageLabel.text")); // NOI18N

        KeyArea.setColumns(20);
        KeyArea.setFont(new java.awt.Font("Monospaced", 0, 12)); // NOI18N
        KeyArea.setRows(5);
        jScrollPane1.setViewportView(KeyArea);

        HexText.setFont(new java.awt.Font("Monospaced", 0, 12)); // NOI18N
        jScrollPane2.setViewportView(HexText);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(currentPageLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(ofLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(totalPageLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(prevPageButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(nextPageButton))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 530, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(nextPageButton)
                    .addComponent(prevPageButton)
                    .addComponent(currentPageLabel)
                    .addComponent(ofLabel)
                    .addComponent(totalPageLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 362, Short.MAX_VALUE))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void nextPageButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextPageButtonActionPerformed
        setDataViewByPageNumber(currentPage + 1);
    }//GEN-LAST:event_nextPageButtonActionPerformed

    private void prevPageButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_prevPageButtonActionPerformed
        setDataViewByPageNumber(currentPage - 1);
    }//GEN-LAST:event_prevPageButtonActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextPane HexText;
    private javax.swing.JTextArea KeyArea;
    private javax.swing.JLabel currentPageLabel;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JButton nextPageButton;
    private javax.swing.JLabel ofLabel;
    private javax.swing.JButton prevPageButton;
    private javax.swing.JLabel totalPageLabel;
    // End of variables declaration//GEN-END:variables
   

//Autopsy will call this when this panel is focused with the file that should be analyzed. When called with null, must clear all references to previous nodes.
//Returns the title of this viewer to display in the tab.
    @Override
    public String getTitle() {
        return "Hex Visualiser";
    }
//Returns a short description of this viewer to use as a tool tip for its tab.
    @Override
    public String getToolTip() {
        return "Displays the hex of a compatible file and highlights the internal structure";
    }
//Create and return a new instance of your viewer. The reason that this is needed is because the specific viewer modules will be found via NetBeans Lookup and the type will only be DataContentViewer. This method is used to get an instance of your specific type.
    @Override
    public DataContentViewer createInstance() {
        return new HexVisualiser();
    }
//Return the Swing Component to display. Implementations of this method that extend JPanel and do a 'return this;'. Otherwise return an internal instance of the JPanel.
    @Override
    public Component getComponent() {
        return this;
    }
//Checks whether the given node is supported by the viewer. This will be used enable for MBR records
    @Override
    public boolean isSupported(Node node) { 
        AbstractFile file = node.getLookup().lookup(AbstractFile.class);
        String extension = file.getNameExtension();
        try{return super.isSupported(node) && extension.equals("mbr");}
        catch(Exception e){}
        return false;
    }
//Checks whether the given viewer is preferred for the Node.
    @Override
    public int isPreferred(Node node) {
        int a = 8;
        return a;
        //the below code had some library import error and has been replaced by int 6, to be forgotten forever hopefully.
        //return ViewerPriority.viewerPriority.Level.getFlag();//gives the highest level of priority for the nodes this can run against
    }

    @Override
    public void setNode(Node node) {//because set node only runs when the module is clicked on the data doesnt display until interacted with
        Content content = DataContentViewerUtility.getDefaultContent(node);
        if (content == null) {
            return;
        }
        
        dataSource = content;
        totalPages = 0;
        if (dataSource.getSize() > 0) {
            totalPages = Math.round((dataSource.getSize() - 1) / PAGE_LENGTH) + 1;
        }
        totalPageLabel.setText(Integer.toString(totalPages));

        this.setDataViewByPageNumber(1);//this should create a worker which then displays the hex
        //launch a pattern worker which will analyse the entire node in the background, the set dataview method should be able to tell when the pattern is loaded
        
    }
    private void setComponentsVisibility(boolean isVisible) {
        currentPageLabel.setVisible(isVisible);
        totalPageLabel.setVisible(isVisible);
        ofLabel.setVisible(isVisible);
        prevPageButton.setVisible(isVisible);
        nextPageButton.setVisible(isVisible);
        }
    private void setDataViewByPageNumber(int page) {
        if (page == 0) {
            return;
        }
        launchWorker(dataSource, (page - 1) * PAGE_LENGTH, page);//creates a new worker when the page number is changed
    }
    private void launchWorker(Content source, long offset, int page) {//creates a swing worker to display the hex from the given file
        if (dataSource == null) {
            return;
        }
        worker = new HexVisualiser.HexWorker(source, offset, page);
        setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));//uncertain what this is/does must find out
        worker.execute();
    }

    /**
     * SwingWorker to fetch hex from the given data source.
     */
    private class HexWorker extends SwingWorker<String, Void> {

        private final byte[] data = new byte[(int) PAGE_LENGTH];
        private final long offset;
        private final Content content;
        private final int newCurrentPage;
        private String errorText = "";
//        private PatternWorker Pworker;

        HexWorker(Content content, long offset, int newCurrentPage) {//constructor
            this.content = content;
            this.offset = offset;
            this.newCurrentPage = newCurrentPage;
            //this.Pworker = new HexVisualiser.PatternWorker(content);
        }

        @Override
        protected String doInBackground() throws Exception {//when a swing worker is on the worker thread the do in background method is called, it isnt called within this program, but sitll runs
            int bytesRead = 0;
            if (content.getSize() > 0) {
                try {
                    bytesRead = content.read(data, offset, PAGE_LENGTH); // read the data
                } catch (TskCoreException ex) {//if no bytes to read, errors and doesnt display anything
                    errorText = NbBundle.getMessage(this.getClass(), "DataContentViewerHex.setDataView.errorText", offset, offset + PAGE_LENGTH);
                }
            }

            // set the data on the bottom and show it
            if (bytesRead <= 0) {//if no bytes to read, errors and doesnt display anything
                errorText = NbBundle.getMessage(this.getClass(), "DataContentViewerHex.setDataView.errorText", offset, offset + PAGE_LENGTH);
            }

            if (errorText.isEmpty()) {
                int showLength = bytesRead < PAGE_LENGTH ? bytesRead : (int) PAGE_LENGTH;
                try{
                    doc = HexVisualiserModule.DataConversion.byteArrayToHex(data, showLength, offset);//converts the bytes to hex by the amount of bytes, limited at the page length constant
                    return "success"; //swingworker needs to return a string and i do not care
                } catch (Exception e){errorText = "wimpwomp back to the drawing board"; return errorText;}//one line because i hate my son and let him eat sand
            } else {
                return errorText;//returns the error if one was found rather than converting the byte array
            }
        }

        @Override
        public void done() {//executes after do in background is completed
            if (isCancelled()) {
                return;
            }

            try {
                if("success".equals(get())){//retrieves results from background method
                    HexText.setDocument(doc);//sets display in visualiser module
                    HexText.repaint();//this should update the text when its done
                }
                //calls a new swingworker which will go through mbr record and match the bytes as well as fills out the key
//                Pworker.execute();
                //ColourCode(HexText, text, 9); // Color every 9 characters differently for this example, modular range will be used later based off of patern matching
                // disable or enable the next button
                if ((errorText.isEmpty()) && (newCurrentPage < totalPages)) {
                    nextPageButton.setEnabled(true);
                } else {
                    nextPageButton.setEnabled(false);
                }

                if ((errorText.isEmpty()) && (newCurrentPage > 1)) {
                    prevPageButton.setEnabled(true);
                } else {
                    prevPageButton.setEnabled(false);
                }
                //ui updates
                currentPageLabel.setText(Integer.toString(newCurrentPage));
                setComponentsVisibility(true); // shows the components that not needed
                HexText.setCaretPosition(0);
                currentPage = newCurrentPage;
                setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));

            } catch (InterruptedException | ExecutionException ex) {
            }
        }
    }
}
//the pattern worker swing worker class is intended to be called from the hexworker when the hex is completeted to parse throough and use a pattern file  
//    private class PatternWorker extends SwingWorker<String, Void>{//text field string passed into pattern worker which should take the file, highlight the bytes and then display them back
//        //done using a swing worker to utilise threading and not hinder efficiency of the program
//        private final byte[] data = new byte[(int) PAGE_LENGTH];
//        private String errorText = "";
//        private String highlightedResult="";//temp
//        private final long offset;
//        private final Content content;
//        
//        @SuppressWarnings("deprecation")//sick and tired i genuinely dont care if its depreciated do the damn thing i imported you for
//        PatternWorker(Content content) {//constructor
//            this.content = content;
//            this.offset = offset;
//        }
//        @Override
//        protected String doInBackground() throws Exception {
//            int bytesRead = 0;
//            try {
//                //in this section the MBR file bytes must be highlighted in accordance with each section of the MBR static structure
//                } 
//            catch (Exception e) {//errors add to the text with stops the worker from returning the result
//                    errorText = NbBundle.getMessage(this.getClass(), "DataContentViewerHex.setDataView.errorText");
//                }
//            if (errorText.isEmpty()) {
//                //
//                //int showLength = bytesRead < PAGE_LENGTH ? bytesRead : (int) PAGE_LENGTH;
//                //return DataConversion.byteArrayToHex(data, showLength, offset);//converts the bytes to hex by the amount of bytes, limited at the page length constant
//                return highlightedResult;
//            } else {
//                return errorText;//returns the error if one was found rather than converting the byte array
//            }
//            }
//
//        @Override
//        protected void done() {//sets the text once the worker is complete
//            try {
//                String text = get();//retrieves results from background method
//                HexText.setText(text);//sets display in visualiser module
//            } catch (Exception ignore) {
//            }
//        }
//    }
//        public static String byteArrayToHex(byte[] array, int length, long arrayOffset, Font font) {
//        return byteArrayToHex(array, length, arrayOffset);
//    }

    /**
     * Return the hex-dump layout of the passed in byte array.
     *
     * @param array       Data to display
     * @param length      Amount of data in array to display
     * @param arrayOffset Offset of where data in array begins as part of a
     *                    bigger file (used for arrayOffset column)
     *
     * @return
     */


